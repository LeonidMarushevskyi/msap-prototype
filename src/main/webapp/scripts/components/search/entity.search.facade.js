'use strict';

angular.module('msapApp')
    .factory('EntitySearchFacade', ['$log', '$injector', '$q', 'ParseLinks',
        function ($log, $injector, $q, ParseLinks) {

            function _processPagination(pagination, headers) {
                if (!_.isNil(pagination) && !_.isNil(headers)) {
                    pagination.totalCount = headers('X-Total-Count');

                    if (pagination.totalCount > 0) {
                        pagination.totalPages = Math.ceil(pagination.totalCount / pagination.pageSize);

                        pagination.from = pagination.pageSize * pagination.pageNumber + 1;
                        pagination.to = pagination.from + pagination.pageSize - 1;
                        if (pagination.to > pagination.totalCount) {
                            pagination.to = pagination.totalCount;
                        }
                    }

                    if (!_.isNil(headers('link'))) {
                        pagination.links = ParseLinks.parse(headers('link'));

                        pagination.hasPrevPage = _.has(pagination, 'links.prev');
                        if (pagination.hasPrevPage) {
                            pagination.prepareGetPrevPage = function() {
                                pagination.pageNumber = pagination.links.prev;
                            };
                        }

                        pagination.hasNextPage = _.has(pagination, 'links.next');
                        if (pagination.hasNextPage) {
                            pagination.prepareGetNextPage = function() {
                                pagination.pageNumber = pagination.links.next;
                            };
                        }
                    }
                }
            }

            /**
             *
             * @param stringQuery
             * @param pagination - Initial pagination {} should have the 'pageSize' key
             *                      and may have the 'sortBy' key with or without the 'sortDirection' key.
             *                      The 'sortBy' is for the entity field name, the 'sortDirection' is for 'asc' or 'desc'.
             * @param serviceQuery
             * @returns {*}
             * @private
             */
            function _serviceQuery(stringQuery, pagination, serviceQuery) {
                if (_.isNil(pagination)) {
                    return {query: stringQuery};
                } else {
                    serviceQuery['query'] = stringQuery;
                    serviceQuery['page'] = pagination.pageNumber;
                    serviceQuery['size'] = pagination.pageSize;

                    if (pagination.sortBy) {
                        serviceQuery['sort'] = pagination.sortBy
                            + (pagination.sortDirection ? ',' + pagination.sortDirection : '');
                    }

                    return serviceQuery;
                }
            }

            /**
             * This is rather an internal function. Use .search() function instead.
             *
             * Examples:
             *      CWSSearchFacade._searchEntity(ReferralSearch, stringQuery).then(...);
             *      CWSSearchFacade._searchEntity(ReferralSearch, stringQuery, errorCallback).then(...);
             *
             * @param EntitySearchService - search service generated by jhipster for an entity (like ReferralSearch)
             * @param stringQuery - Elasticsearch String Query (having specific syntax); Search will not be performed if it's blank.
             * @param pagination
             * @param errorCallback
             * @return promise of the search service query() method or null if nothing to search
             */
            function _searchEntity(EntitySearchService, stringQuery, pagination, errorCallback) {
                return _.isNil(stringQuery) || _.isEmpty(stringQuery.trim()) ? null :
                    EntitySearchService.query(
                        _serviceQuery(stringQuery, pagination, {}),
                        function (results, headers) {
                            _processPagination(pagination, headers);
                        },
                        angular.isFunction(errorCallback) ? errorCallback : function (response) {
                            // response.status === 404
                            $log.error('searchEntity failed: ' + response.data);
                        }
                    ).$promise;
            }

            function _isSearchOption(value, key) {
                return _.startsWith(key, '$') && key !== '$value';
            }

            // assume searchClause is {*}
            function _extractSearchOptions(searchClause) {
                return _.pickBy(searchClause, _isSearchOption);
            }

            // assume searchClause is {*}
            function _extractSearchPairs(searchClause) {
                return _.omitBy(searchClause, function (value, key) {
                    return _isSearchOption(value, key) || _.isEmpty(_.toString(value));
                });
            }

            // before: { $field: 'lastName', $value: 'Smith', fn1: 'value1', fn2: 'value2' }
            // after: { lastName: 'Smith', fn1: 'value1', fn2: 'value2' }
            function _transformFieldPair(searchExpr) {
                return _.transform(searchExpr, function (result, value, key) {
                    if (key === '$field') {
                        result[ value ] = searchExpr[ '$value' ];
                    } else if (key !== '$value') {
                        result[ key ] = value;
                    }
                }, {});
            }

            /*
             * _getReusableOptions({ $anySuffix: true })
             *      ---> { $anySuffix: true }
             * _getReusableOptions({ DEFAULTS: { $anySuffix: true }, OPTS_1: { $phonetic: true } })
             *      ---> { $anySuffix: true }
             * _getReusableOptions({ DEFAULTS: { $anySuffix: true }, OPTS_1: { $phonetic: true } }, 'DEFAULTS')
             *      ---> { $anySuffix: true }
             * _getReusableOptions({ DEFAULTS: { $anySuffix: true }, OPTS_1: { $phonetic: true } }, 'OPTS_1')
             *      ---> { $phonetic: true }
             */
            function _getReusableOptions(reusableOptions, key) {
                if (_.isNil(reusableOptions)) {
                    return {};

                } else if (_.isNil(key)) {
                    return _getReusableOptions(reusableOptions, 'DEFAULTS');

                } else {
                    return _.extend({}, _.hasIn(reusableOptions, key) ? reusableOptions[key] : reusableOptions);
                }
            }

            /**
             * _mergeSearchOptions(
             *      { $anySuffix: false },
             *      { DEFAULTS: { $anySuffix: true, $minWordLength: 3 }, OPTS_1: { $phonetic: true } }
             * )
             *      ---> { $anySuffix: false, $minWordLength: 3 }
             *
             * _mergeSearchOptions(
             *      { $anySuffix: false, $options: 'OPTS_1' },
             *      { DEFAULTS: { $anySuffix: true, $minWordLength: 3 }, OPTS_1: { $phonetic: true } }
             * )
             *      ---> { $anySuffix: false, $phonetic: true }
             *
             * @param searchOptions - can be null or { ... }
             * @param reusableOptions - can be null or { ... }; entries of reusableOptions will be overridden by searchOptions
             * @returns {*}
             * @private
             */
            function _mergeSearchOptions(searchOptions, reusableOptions) {
                if (_.isEmpty(searchOptions)) {
                    return _getReusableOptions(reusableOptions, 'DEFAULTS');

                } else if (_.isEmpty(reusableOptions)) {
                    return _.extend({}, searchOptions);

                } else if (_.hasIn(searchOptions, '$options')) {
                    return _.extend({},
                        _getReusableOptions(reusableOptions, 'DEFAULTS'),
                        _getReusableOptions(reusableOptions, searchOptions.$options),
                        searchOptions);

                } else {
                    return _.extend({},
                        _getReusableOptions(reusableOptions, 'DEFAULTS'),
                        searchOptions);
                }
            }

            function _whenConditionIsTrue(searchOptions) {
                if (!_.hasIn(searchOptions, '$when')) {
                    return true;

                } else if (_.isUndefined(searchOptions.$when)) {
                    return false;

                } else if (_.isFunction(searchOptions.$when)) {
                    return (searchOptions.$when)();

                } else {
                    return searchOptions.$when;
                }
            }

            /*
             * _applySearchOptionsToString('abc', { $anySuffix: true }) ---> 'abc*'
             */
            function _applySearchOptionsToString(searchString, searchOptions) {
                if (_.isNil(searchString) || !_whenConditionIsTrue(searchOptions)) {
                    return '';
                }

                if (searchString.match(/\s/) && searchOptions.$splitPhrase) {
                    return '(' + _buildStringQuery(searchString.split(/\s+/), searchOptions) + ')';
                }

                if (!_.isNil(searchOptions.$minWordLength) && searchString.length < searchOptions.$minWordLength) {
                    return '';
                }

                if (searchOptions.$exactMatch || searchOptions.$fuzziness) {
                    searchOptions.$anyPrefix = false;
                    searchOptions.$anySuffix = false;
                }

                if (searchString.match(/\s/)) {
                    searchString = '"'+ searchString + '"';
                }

                if (searchOptions.$anyPrefix) {
                    searchString  = '*' + searchString;
                }

                if (searchOptions.$anySuffix) {
                    searchString = searchString + '*';
                }

                if (searchOptions.$fuzziness) {
                    searchString = searchString + '~' + searchOptions.$fuzziness;
                }

                if (searchOptions.$boost) {
                    searchString = searchString + '^' + searchOptions.$boost;
                }

                return searchString;
            }

            function _isFieldNameLikeId(fieldName) {
                fieldName = fieldName.toLowerCase();
                return fieldName === 'id' || fieldName === '+id' || fieldName === '-id' || new RegExp("\.id$").test(fieldName);
            }

            function _applySearchOptionsToFieldName(fieldName, searchOptions) {
                if (searchOptions.$detectId && _isFieldNameLikeId(fieldName)) {
                    searchOptions.$minWordLength = 1;
                    searchOptions.$exactMatch = true;
                    searchOptions.$fuzziness = 0;
                }

                if (searchOptions.$phonetic) {
                    searchOptions.$exactMatch = true;
                    searchOptions.$fuzziness = 0;
                    return fieldName + '.phonetic';

                } else {
                    return fieldName;
                }
            }

            /*
             * _reduceSearchPairs({ fname: 'value1', lname: 'value2' }, { $anySuffix: true })
             *      ---> 'fname:value1* lname:value2*'
             *
             * _reduceSearchPairs({ id: 5, gender: '' }, { $minWordLength: 1 })
             *      ---> 'id:5'
             */
            function _transformSearchPair(result, fieldValue, fieldName, searchOptions) {
                if (_whenConditionIsTrue(searchOptions)) {
                    fieldName = _applySearchOptionsToFieldName(fieldName, searchOptions);
                    fieldValue =
                        (angular.isArray(fieldValue) ? '(' : '')
                        + _buildStringQuery(fieldValue, searchOptions)
                        + (angular.isArray(fieldValue) ? ')' : '');

                    if (!(_.isEmpty(fieldValue) || _.includes(['{}', '[]', '[}', '{]'], fieldValue))) {
                        result[ fieldName ] = fieldValue;
                    }
                }
            }
            //
            function _reduceSearchPairs(searchPairs, searchOptions) {
                return _(searchPairs).transform(function (result, fieldValue, fieldName) {
                    _transformSearchPair(result, fieldValue, fieldName,
                        _.extend({}, searchOptions)
                    );
                }, {}).map(function (fieldValue, fieldName) {
                    return fieldName + ':' + fieldValue;
                }).join(' ');
            }
            //
            /**
             * Examples:
             *      _range('[]', [1, 5]) ---> '[1 TO 5]'
             *      _range('{]', [10, '*']) ---> '{10 TO *]'
             *
             * @param inclusiveness one of: '[]', '{}', '{]', '[}'
             * @param range - 2-element array
             * @private
             */
            function _range(inclusiveness, range) {
                if (_.isEmpty(range) || !_.isArray(range) || range.length !== 2) {
                    $log.error('Invalid search expression: ', range);
                    return '';
                }
                return inclusiveness[0] + range[0] + ' TO ' + range[1] + inclusiveness[1];
            }

            function _isInsufficient(searchClause) {
                return _.isPlainObject(searchClause) && searchClause.$insufficient;
            }

            function _reduceArraySearchExpr(sufficientSearchClauses, insufficientSearchClauses) {
                return sufficientSearchClauses
                    ? _([insufficientSearchClauses, sufficientSearchClauses]).compact().join(' ')
                    : '';
            }

            function _includeOrExcludeGroup(sign, searchExpr, reusableOptions) {
                return _([
                    sign
                    + (angular.isArray(searchExpr[sign]) || _.isPlainObject(searchExpr[sign]) ? '(' : '')
                    + _buildStringQuery(searchExpr[sign], reusableOptions)
                    + (angular.isArray(searchExpr[sign]) || _.isPlainObject(searchExpr[sign]) ? ')' : ''),
                    _buildStringQuery(_.omit(searchExpr, sign), reusableOptions)
                ]).without(sign, sign + '()').compact().join(' ');
            }

            function _buildStringQuery(searchExpr, reusableOptions) {
                if (_.isNil(searchExpr)) {
                    return '';

                } else if (angular.isNumber(searchExpr)) {
                    return _applySearchOptionsToString(_.toString(searchExpr), _mergeSearchOptions(null, reusableOptions));

                } else if (angular.isString(searchExpr)) {
                    return _applySearchOptionsToString(searchExpr, _mergeSearchOptions(null, reusableOptions));

                } else if (angular.isArray(searchExpr)) {
                    // for grouping;
                    // to have, for example, '+(fn1:abc fn2:def)' from { '+': [ { fn1: 'abc', fn2: 'def' } ] }

                    var _buildString = function (searchClause) {
                        return _buildStringQuery(searchClause, reusableOptions);
                    };

                    return _reduceArraySearchExpr(
                        _(searchExpr).reject(_isInsufficient).map(_buildString).compact().join(' '),
                        _(searchExpr).filter(_isInsufficient).map(_buildString).compact().join(' ')
                    );

                } else if (_.isPlainObject(searchExpr)) {

                    if (_.isEmpty(searchExpr)) {
                        return '';

                    } else if (_.hasIn(searchExpr, '$field')) {
                        if (_.hasIn(searchExpr, '$value')) {
                            // before: { $field: 'firstName', $value: $scope.inputName }
                            // after: { firstName: $scope.inputName }
                            return _buildStringQuery(_transformFieldPair(searchExpr), reusableOptions);

                        } else {
                            // deny incomplete clause like { $field: 'firstName' }
                            $log.error('Invalid search expression: ', searchExpr);
                            return '';
                        }

                    } else if (_.hasIn(searchExpr, '$value')) {
                        // before: { $value: 'abc', field1: value1, field2: value2 }
                        // after: ----> 'abc ' + _buildStringQuery({ field1: value1, field2: value2 }, ...)
                        return _([
                            _buildStringQuery(searchExpr['$value'],
                                _mergeSearchOptions(_extractSearchOptions(searchExpr), reusableOptions)
                            ),
                            _buildStringQuery(_.omit(searchExpr, '$value'), reusableOptions)
                        ]).compact().join('');

                    } else if (_.hasIn(searchExpr, '+')) {
                        // for things like { '+': [ 'abc', 'def' ] }
                        return _includeOrExcludeGroup('+', searchExpr, reusableOptions);

                    } else if (_.hasIn(searchExpr, '-')) {
                        // for things like { '-': [ fn1: 'abc', fn2: 'def' ] }
                        return _includeOrExcludeGroup('-', searchExpr, reusableOptions);

                        // age: { '{}': [1, 5] } ---> 'age:{1 TO 5}'
                        // age: { '{]': [10, '*'] } ---> 'age:{10 TO *]'
                    } else if (_.hasIn(searchExpr, '[]')) { // inclusive
                        return _range('[]', searchExpr['[]']);
                    } else if (_.hasIn(searchExpr, '{}')) { // exclusive
                        return _range('{}', searchExpr['{}']);
                    } else if (_.hasIn(searchExpr, '[}')) {
                        return _range('[}', searchExpr['[}']);
                    } else if (_.hasIn(searchExpr, '{]')) {
                        return _range('{]', searchExpr['{]']);

                    } else {
                        // before: { field1: value1, field2: value2 }
                        // after: 'field1:value1 field2:value2'
                        return _reduceSearchPairs(_extractSearchPairs(searchExpr),
                            _mergeSearchOptions(_extractSearchOptions(searchExpr), reusableOptions));
                    }

                } else {
                    $log.error('Unsupported search expression: ', searchExpr);
                    return '';
                }
            }

            function createSearchResults(stringQuery, entityName, data) {
                return {
                    searchPerformed: !_.isEmpty(stringQuery),
                    stringQuery: stringQuery,
                    entityName: entityName,
                    data: data
                };
            }

            function _searchStringQuery(stringQuery, entityName, pagination) {
                return createSearchResults(stringQuery, entityName,
                    _.isEmpty(stringQuery) ? []
                        : _searchEntity($injector.get(entityName + 'Search'), stringQuery, pagination)
                );
            }

            function _normalizePagination(pagination) {
                if (_.isNil(pagination)) {
                    return pagination;

                } else {
                    if (_.isNil(pagination.pageNumber)) {
                        pagination.pageNumber = 0;
                    }
                    if (_.isNil(pagination.pageSize)) {
                        pagination.pageSize = 10;
                    }
                    return pagination;
                }
            }

            function search(searchExpr, entityName, reusableOptions, pagination) {
                return $q.all(_searchStringQuery(
                    _buildStringQuery(searchExpr, reusableOptions).trim(),
                    entityName,
                    _normalizePagination(pagination)
                ));
            }

            function fetchList(searchExpr, entityName, reusableOptions, pagination) {
                return search(searchExpr, entityName, reusableOptions, pagination).then(function (result) {
                    return result.data;
                });
            }

            return {
                search: search,
                fetchList: fetchList,
                createSearchResults: createSearchResults
            };

        }]);
